# Environment Configuration Guide

This guide explains how to configure environment variables for different deployment scenarios.

## Overview

The backend uses different `.env` files depending on how you're running it:

| Scenario | Environment File | Services |
|----------|-----------------|----------|
| **Local Development (NestJS)** | `.env.local` | NestJS runs locally, services in Docker |
| **Docker Compose (All phases)** | `.env.compose` | Everything runs in Docker |
| **AWS EC2 Deployment** | Auto-generated by CDK | Everything runs in Docker on EC2 |

---

## Local Development

**When to use**: Developing NestJS code with hot reload

### Setup

```bash
# 1. Copy the example file
cp .env.local.example .env.local

# 2. Start Docker services only
docker-compose up -d postgres influxdb redis mosquitto

# 3. Run NestJS locally
npm run start:dev
```

### Configuration

File: `.env.local`

**Key Settings:**
- `NODE_ENV=development`
- `ENABLE_MOCK_DATA=true` - Generates test data
- `MQTT_BROKER_URL=mqtt://localhost:1884` - Note the port mapping (1883→1884)
- Services point to `localhost` with Docker-mapped ports

**When to edit:**
- Testing different mock data configurations
- Integrating with local frontend on different port
- Testing email/Stripe integrations

---

## Docker Compose Deployment

**When to use**:
- Local full-stack development
- Running everything in Docker
- All deployment phases (planning, testing, production)

### Setup

```bash
# 1. Copy the template
cp .env.compose.template .env.compose

# 2. Generate secure secrets
export JWT_SECRET=$(openssl rand -base64 48)
export POSTGRES_PASSWORD=$(openssl rand -base64 24)
export REDIS_PASSWORD=$(openssl rand -base64 24)
export INFLUXDB_PASSWORD=$(openssl rand -base64 24)
export INFLUXDB_TOKEN=$(openssl rand -base64 64)

# 3. Edit .env.compose and replace placeholders

# 4. Start all services
docker-compose up -d
```

### Configuration by Phase

#### Planning Phase (Local)

```bash
# .env.compose
NODE_ENV=development
ENABLE_MOCK_DATA=true  # For testing without real machines
FRONTEND_URL=http://localhost:3030

# Use strong secrets even in development
JWT_SECRET=<generated-secret>
POSTGRES_PASSWORD=<generated-password>
REDIS_PASSWORD=<generated-password>
INFLUXDB_PASSWORD=<generated-password>
INFLUXDB_TOKEN=<generated-token>
```

**Cost**: $0/month (runs on your laptop)

#### Testing Phase (1-10 machines)

```bash
# .env.compose (on EC2 or local for testing)
NODE_ENV=production
ENABLE_MOCK_DATA=false  # Using real machine data
FRONTEND_URL=https://your-frontend-url.com

# IMPORTANT: Use production-grade secrets
JWT_SECRET=<strong-random-secret>
POSTGRES_PASSWORD=<strong-random-password>
# ... other strong secrets
```

**If running on EC2**: CDK deployment script auto-generates `.env.compose` on the instance

#### Production Phase (50-100 machines)

```bash
# .env.compose (on EC2)
NODE_ENV=production
ENABLE_MOCK_DATA=false
FRONTEND_URL=https://your-production-frontend.com

# CRITICAL: Rotate secrets regularly
JWT_SECRET=<production-secret>
POSTGRES_PASSWORD=<production-password>
# ... other production secrets

# Optional: Enable Stripe billing
STRIPE_SECRET_KEY=sk_live_...
STRIPE_WEBHOOK_SECRET=whsec_...

# Optional: Enable email notifications
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASSWORD=your-app-password
```

---

## AWS EC2 Deployment

**When to use**: AWS deployment (testing or production phases)

### How It Works

The CDK deployment script automatically generates `.env.compose` on the EC2 instance with:
- Auto-generated secure secrets
- Correct service hostnames for Docker network
- Environment-appropriate settings

### User Data Script

Located in `infrastructure/lib/opcua-backend-stack.ts`, the user data script:

1. Clones your repository
2. Creates `.env.compose` with secure auto-generated secrets
3. Runs `docker-compose up -d`

**You don't manually create `.env` files for AWS deployments.**

### Deployment Commands

```bash
# Planning Phase (on-demand staging)
DEPLOY_ENV=planning ./infrastructure/deploy.sh

# Testing Phase (1-10 machines, always-on)
DEPLOY_ENV=testing ./infrastructure/deploy.sh

# Production Phase (50-100 machines)
DEPLOY_ENV=production ./infrastructure/deploy.sh
```

### Viewing Environment on EC2

```bash
# SSH into instance
./infrastructure/scripts/manage-instance.sh ssh

# View environment variables (secrets are hidden)
cd /opt/opcua-backend
cat .env.compose | grep -v PASSWORD | grep -v SECRET | grep -v TOKEN
```

---

## Security Best Practices

### Secret Generation

**Always generate unique secrets for each environment:**

```bash
# JWT Secret (48 bytes = 64 chars base64)
openssl rand -base64 48

# Database Passwords (24 bytes = 32 chars base64)
openssl rand -base64 24

# InfluxDB Token (64 bytes = 88 chars base64)
openssl rand -base64 64
```

### Secret Rotation

Rotate secrets every 3-6 months:

1. Generate new secrets
2. Update `.env.compose` on running instance
3. Restart services: `docker-compose restart`
4. Update secrets in backup storage

### Environment File Permissions

```bash
# Restrict access to environment files
chmod 600 .env.compose
chmod 600 .env.local

# Never commit to git
echo ".env.compose" >> .gitignore
echo ".env.local" >> .gitignore
```

### What NOT to Commit

**NEVER commit these files:**
- ❌ `.env.compose`
- ❌ `.env.local`
- ❌ `.env.production`
- ❌ Any file with actual secrets

**Safe to commit (these are templates):**
- ✅ `.env.compose.template`
- ✅ `.env.local.example`
- ✅ `.env.ec2.example`

---

## Environment Variables Reference

### Required Variables

| Variable | Description | Example |
|----------|-------------|---------|
| `NODE_ENV` | Runtime environment | `development`, `production` |
| `PORT` | Backend port | `3000` |
| `JWT_SECRET` | Authentication secret | `<48-byte base64>` |
| `POSTGRES_HOST` | PostgreSQL host | `postgres` (Docker), `localhost` (local) |
| `POSTGRES_PASSWORD` | PostgreSQL password | `<24-byte base64>` |
| `REDIS_HOST` | Redis host | `redis` (Docker), `localhost` (local) |
| `REDIS_PASSWORD` | Redis password | `<24-byte base64>` |
| `INFLUXDB_URL` | InfluxDB URL | `http://influxdb:8086` |
| `INFLUXDB_TOKEN` | InfluxDB auth token | `<64-byte base64>` |
| `MQTT_BROKER_URL` | MQTT broker URL | `mqtt://mosquitto:1883` |

### Optional Variables

| Variable | Description | When to Use |
|----------|-------------|-------------|
| `ENABLE_MOCK_DATA` | Generate test data | Development/testing |
| `FRONTEND_URL` | CORS origin | Configure for frontend URL |
| `STRIPE_SECRET_KEY` | Stripe billing | If using subscriptions |
| `STRIPE_WEBHOOK_SECRET` | Stripe webhooks | If using subscriptions |
| `SMTP_HOST` | Email server | If using email notifications |
| `AWS_REGION` | AWS region | If using AWS services |

---

## Troubleshooting

### Issue: Backend can't connect to services

**Symptom**: `ECONNREFUSED` errors in logs

**Solution**:
```bash
# Check if services are running
docker-compose ps

# Check if hostnames are correct
# Docker Compose: use service names (postgres, redis, influxdb)
# Local dev: use localhost

# Verify .env file
cat .env.compose | grep HOST
```

### Issue: Invalid credentials

**Symptom**: Authentication failed, database connection refused

**Solution**:
```bash
# Verify secrets match between .env and Docker services
docker-compose down -v  # WARNING: Deletes data
docker-compose up -d
```

### Issue: MQTT port conflict

**Symptom**: `Port 1883 already in use`

**Solution**:
```bash
# Local dev uses port mapping 1883→1884
# Update .env.local:
MQTT_BROKER_URL=mqtt://localhost:1884

# Or stop conflicting service
sudo lsof -i :1883
```

### Issue: Frontend CORS errors

**Symptom**: `Access-Control-Allow-Origin` errors

**Solution**:
```bash
# Update FRONTEND_URL in .env.compose
FRONTEND_URL=https://your-actual-frontend-url.com

# Restart backend
docker-compose restart backend
```

---

## Environment Migration

### Local → AWS Testing

```bash
# 1. Backup local data (optional)
docker exec opcua-postgres pg_dump -U postgres opcua_dashboard > backup.sql

# 2. Deploy to AWS
cd infrastructure
DEPLOY_ENV=testing ./deploy.sh

# 3. Restore data on EC2 (optional)
./scripts/manage-instance.sh ssh
# ... upload and restore backup
```

### Testing → Production

```bash
# 1. Backup testing data
cd infrastructure
./scripts/backup-data.sh

# 2. Deploy production environment
DEPLOY_ENV=production cdk deploy

# 3. Restore data
./scripts/restore-data.sh backups/<backup-directory>
```

---

## Quick Reference

### Which file do I use?

```
Running NestJS locally with Docker services?
  → Use .env.local

Running everything in Docker locally?
  → Use .env.compose

Deploying to AWS with CDK?
  → .env.compose is auto-generated, no manual setup needed
```

### How do I know if my environment is configured correctly?

```bash
# Check health endpoint
curl http://localhost:3000/health

# Expected response:
{"status":"ok","timestamp":"2025-01-15T10:30:00.000Z"}

# Check Docker services
docker-compose ps

# All services should show "Up" status
```

---

## See Also

- [DEPLOYMENT.md](../DEPLOYMENT.md) - Complete deployment guide
- [README.md](../README.md) - Quick start instructions
- [PHASED_DEPLOYMENT.md](../infrastructure/PHASED_DEPLOYMENT.md) - Cost optimization guide
